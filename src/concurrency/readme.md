# Concurrency

Concurrency is running more than one tasks with the help of context switch (by using OS scheduling). Concurrency is done in a single
process or thread. Parallelism is executing the code on multiple cores (multiple threads)

### Parallel Execution

1. Two programs execute in parallel if they execute at exactly the same time
2. One core runs one instruction at a time
3. To run instructions in parallel you need multiple cores
4. Some tasks must be executed sequentially
5. Some tasks cannot be parallelised even with excess hardware due to their nature

#### Von Neumann Bottleneck

The processor depends upon the memory to get the data. The CPU has to access memory in order to complete its job. Memory access is slower than the CPU speed. Even if we increase the clock speed we would still need to wait for the data to be available to us.

To solve this problem, engineers have added cache memory, which has faster access time as compared to main memory, this significantly speeded up the execution time.

This had been the case 5-6 years from now (20 October). Upgrading hardware is no longer feasible. Moore's law is dying..

Moore's Law

The transistor density is doubled every two years. But this law is breaking these days. This is because it has become physcially impossible to upgrade the hardware as the heat generated by the transistor can no longer be handled.

Power Wall

Power/Temparature problem: Transistors consume power when they switch

Equation of Power (P) = alpha * (CFV^2)

Dennard Scaling

Since voltage has a significant impact on power, when you reduce the size of the transistor you should also plan to reduce the voltage as well, so the the whole system scales down in sync. This is called Dennard Scaling

Concurrency Vs Parallelism

1. Concurrent execution is not necessarily the same as parallel execution
2. Concurrent: Two tasks are concurrent if their start and end time overlaps, Task 1 starts, sometime later task 2 starts task 1 stops, task 2 ends, task1 resumes and task 1 ends
3. Parallelism: Two tasks execute at exactly the same time, parallel tasks are always concurrent
4. Parallelism must happen on different hardware (...different cores)
5. Concurrent tasks must be executed on same hardware

In Concurrent Programming:

1. Programmer determines which tasks can be executed in parallel
2. The programmer determines which tasks can (not must) be executed in parallel, the actual mapping to hardware is done by the OS and Go runtime scheduler
3. Concurrency improves performance, even without parallelism

#### Processes

Each program is given a process to execute, each process has its own memory ( stack, and heap ),  and set of registers.
The job of the OS is to run multiple processes concurrently. The OS makes use of a principle called Scheduling to manage the execution of the processes. 

#### Scheduling Processes

1. Operating system schedules processes for execution
2. Gives the illusion of parallel execution. On a single core machine, the OS schedules the processes (~20ms turn) for the processes to switch.
3. OS uses many different scheduling algorithms like Round Robin, priority scheduling etc.

#### Context Switch

When the control swithces from one process to another, it is called context switching. 

1. Control flow changes from one process to another.
2. The OS must store the current state of the running process which is going to be stopped
3. The OS must retrieve the current state of the running process which is going to be started

#### Thread

In the early days of *nix based OS, there were no threads. There were only processes. The context switching used to take a lot of time
becauase when you switch a context memory retrieval is required. And memory access is slow.

So, the concept of thread was introduced

1. Threads share some context
2. Many threads can exist in one process
3. Nowadays, OS schedules threads instead of the processes
4. Each thread has its own stack, data registeres and code, but they share the same virtual memory and file descriptors
5. Context switch between threads is much faster than that between the processes becauase of the shared virtual memory and file descriptors
